import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Adding links

Use the `navigateTo` function to redirect users to Reddit content or external websites in response to user actions, such as button clicks. The `navigateTo` function is available in `onPress` handlers for [Interactive Posts](/docs/interactive_posts.md) and [Menu Actions](/docs/capabilities/menu-actions.md). You can redirect to a `url` string or to objects such as [`Subreddit`](/docs/api/redditapi/classes/models.Subreddit.md), [`Post`](/docs/api/redditapi/classes/models.Post.md), or [`Comment`](/docs/api/redditapi/classes/models.Comment.md).

<Tabs>
  <TabItem value="url" label="URL" default>
```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.addMenuItem({
  label: 'Navigate to url',
  location: 'subreddit',
  onPress: async (_event, context) => {
    // highlight-start
    const url = 'https://www.reddit.com/r/movies/comments/tzxev3/';
    context.ui.navigateTo(url);
    // highlight-end
  },
});

export default Devvit;
```
  </TabItem>
  <TabItem value="subreddit" label="Subreddit">
```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.configure({ redditAPI: true });

Devvit.addMenuItem({
  label: 'Navigate to subreddit',
  location: 'subreddit',
  onPress: async (_event, context) => {
    // highlight-start
    const subredditId = 't5_2qh1o';
    const post = await context.reddit.getSubredditById(subredditId);
    context.ui.navigateTo(post);
    // highlight-end
  },
});

export default Devvit;
```
  </TabItem>
  <TabItem value="post" label="Post">
```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.configure({ redditAPI: true });

Devvit.addMenuItem({
  label: 'Navigate to post',
  location: 'subreddit',
  onPress: async (_event, context) => {
    // highlight-start
    const postId = 't3_tzxev3';
    const post = await context.reddit.getPostById(postId);
    context.ui.navigateTo(post);
    // highlight-end
  },
});

export default Devvit;
```
  </TabItem>
  <TabItem value="comment" label="Comment">
```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.configure({ redditAPI: true });

Devvit.addMenuItem({
  label: 'Navigate to comment',
  location: 'subreddit',
  onPress: async (_event, context) => {
    // highlight-start
    const commentId = 't1_i426ob1';
    const comment = await context.reddit.getCommentById(commentId);
    context.ui.navigateTo(comment);
    // highlight-end
  },
});

export default Devvit;
```
  </TabItem>
</Tabs>

:::warning
When linking to Reddit content, the `navigateTo` function requires the [app account](/docs/about_devvit.md#app-account) to have access to the content. If the app account does not have access, the redirect will fail.
:::

## Interactive posts
A button with an `onPress` handler that navigates to a post.

```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.configure({ redditAPI: true });

// Interactive post definition
Devvit.addCustomPostType({
  name: 'Name',
  render: (context) => {
    return (
      <vstack height="100%" alignment="middle center">
        <button
          onPress={async () => {
            // highlight-start
            const postId = 't3_tzxev3';
            const post = await context.reddit.getPostById(postId);
            context.ui.navigateTo(post);
            // highlight-end
          }}
        >
          Navigate to post
        </button>
      </vstack>
    );
  },
});

// Menu action to instantiate the interactive post
Devvit.addMenuItem({
  label: 'Add navigation post',
  location: 'subreddit',
  onPress: async (_event, context) => {
    const subreddit = await context.reddit.getCurrentSubreddit();
    await context.reddit.submitPost({
      title: 'Navigate to post',
      subredditName: subreddit.name,
      preview: (
        <vstack height="100%" width="100%" alignment="middle center">
          <text>Loading ...</text>
        </vstack>
      ),
    });
    context.ui.showToast('Created post!');
  },
});

export default Devvit;
```

## External URLs

Users see a confirmation dialog before going to external URLs.

![Confirmation dialog for external links](../assets/capabilities/adding-links/adding-links-external-link-dialog.png)

```tsx title="main.tsx"
import { Devvit } from '@devvit/public-api';

Devvit.addMenuItem({
  label: 'Navigate to url',
  location: 'subreddit',
  onPress: async (_event, context) => {
    // highlight-start
    const url = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';
    context.ui.navigateTo(url);
    // highlight-end
  },
});

export default Devvit;
```

## Limitations

- `navigateTo` is not supported in [playground](https://developers.reddit.com/play).
- `url` must be http/https
- `url` must have a domain


# App configurations

Include configuration settings in your app.

![An example form with all field types](../assets/capabilities/app-configurations/app-configurations-all-types.png)

Configuration settings let users change the functionality and behavior of an app. Use the following steps to add settings at the global app-scope.

1. Use `Devvit.addSettings` to define the fields with scope as `SettingsScope.App`

```tsx
import { Devvit, SettingScope } from '@devvit/public-api';

Devvit.addSettings([
  {
    type: 'string',
    name: 'my-feature-flag',
    label: 'Feature Flag to rollout a new change',
    scope: SettingScope.App, // this can be a string literal 'app' as well
  },
]);
```

2. Store the app setting value via CLI. Keep in mind this operation modifies the value across all installations.

```bash
devvit settings set my-feature-flag
```

3. Access the global setting inside your app. Example menu item to show a toast with the setting value:

```tsx
Devvit.addMenuItem({
  label: 'Test App Settings',
  location: 'subreddit',
  onPress: async (_event, { ui, settings }) => {
    // retrieve the global setting
    const featureFlag = await settings.get('my-feature-flag');
    ui.showToast(`Retrieved the setting featureFlag as ${featureFlag}`);
  },
});
```

Once the app is installed, the configuration settings are available on the Install Settings page. Moderators add the required input and save the changes to configure the app. Note that these configurations are limited to the subreddit where the app is installed, so your app can be uniquely configured to each subreddit’s specific needs.

## Input types

There are currently five supported types of input:

- String or `'string'`
- Boolean or `'boolean'`
- Number or `'number'`
- Dropdown selection or `'select'`
- Paragraph or `'paragraph'`

See the [Forms page](./forms.md) for more detail.

## Configuring settings within your app

You can use the following code snippets as a guide to adding configuration settings to your app:

1. First, make sure this import is at the top of your file.

```tsx
import { Devvit } from '@devvit/public-api';
```

2. Use `Devvit.addSettings` to define any input fields you want to add to your settings form. Each field needs to be assigned a type, name, and label. You can provide the dropdown options for selection fields, as well as determine if the user can select more than one option within the dropdown. The label is the only text that will be visible on the form, so use this to communicate what the moderator should enter in each input field.

```tsx
Devvit.addSettings([
  {
    type: 'string',
    name: 'text-input',
    label: 'Enter your text input:',
    onValidate: async ({ value }) => {
      if (value !== 'bird') {
        return 'Word must be "bird"';
      }
    },
  },
  {
    type: 'boolean',
    name: 'bool-input',
    label: 'Use the switch to determine if some setting should be enabled:',
  },
  {
    type: 'select',
    name: 'select-input',
    label: 'Select one of the options:',
    options: [
      {
        label: 'Option 1',
        value: 'Option 1',
      },
      {
        label: 'Option 2',
        value: 'Option 2',
      },
    ],
    multiSelect: false,
  },
  {
    type: 'select',
    name: 'multiselect-input',
    label: 'Select multiple options:',
    options: [
      {
        label: 'Option 1',
        value: 'Option 1',
      },
      {
        label: 'Option 2',
        value: 'Option 2',
      },
      {
        label: 'Option 3',
        value: 'Option 3',
      },
    ],
    multiSelect: true,
  },
  {
    type: 'number',
    name: 'number-input',
    label: 'Enter your number input:',
  },
  {
    type: 'group',
    label: 'This is a GROUP field',
    fields: [
      {
        type: 'string',
        name: 'group-text-input',
        label: 'Group: Enter your text input:',
      },
      {
        type: 'boolean',
        name: 'group-bool-input',
        label: 'Group: Use the switch to determine if some setting should be enabled:',
      },
    ],
  },
]);
```

### Input validation

![Input validation](../assets/capabilities/app-configurations/app-configurations-validation.png)

Devvit app configurations also support input validation. As the app developer, you can set restrictions on what kind of input must be entered in each field.

For example, setting a maximum number:

```tsx
onValidate: (event) => {
  if (event.value! > 10) {
    return 'Number too high!';
  }
};
```

To use validation, add the `onValidate` handler to the settings field object, like this:

```tsx
  {
    type: 'number',
    name: 'number-input',
    label: 'Enter your number input:',
    onValidate: (event) => {
      if (event.value! > 10) { return 'Number too high! Must be lower than 10.' }
    }
  },
```

## Retrieving settings within your app

After you've written the configuration settings for your app, you can see the input that has been entered by the moderator by using `getSettings`.

1. Add the following imports to the top of your file:

```tsx
import { Devvit } from '@devvit/public-api';
```

2. Use `Devvit.addMenuItem` to create a menu item that will trigger a toast message containing the form input.

```tsx
Devvit.addMenuItem({
  label: 'Test Action',
  location: Context.SUBREDDIT,
  onPress: (_, context) {
    // to get all settings
    const settings = await context.settings.getAll();
    // to get an individual setting
    const textFieldInput = await context.settings.get('text-input');

    ui.showToast(JSON.stringify(textFieldInput))
  },
});
```

![Settings retrieval](../assets/capabilities/app-configurations/app-configurations-data-toast.png)

# Cache helper

Cache helper lets you build a more performant app by reducing the number of server side calls for the same data. You can create a short-term cache that stores JSON objects in your Devvit app for a limited amount of time. This is valuable when you have many clients trying to get the same data for example with a stock ticker value or with a sports score.

Under the covers, it's Redis plus a local in-memory write-through cache. This provides a pattern for fetching data without involving a scheduler and allows granular, small TTLs (1 second~). Cache helper lets the app make one request for the data, save the response, and provide this response to all users requesting the same data.

:::warning
**Do not cache sensitive information**. Cache helper randomly selects one user to make the real request and saves the response to the cache for others to use. You should only use cache helper for non-personalized fetches, since the same response is available to all users.
:::

## Usage

You need to enable [Redis](./redis.md) in order to use Cache helper.

```tsx
Devvit.configure({
  redis: true,
  // other capabilities
});
```

## Parameters

| **Parameters** | **Description**                                                                                                                                                                                                                                                                                                            |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `key`          | This is a string that identifies a cached response. Instead of making a real request, the app gets the cached response with the key you provide. Make sure to use different keys for different data. For example, if you’re saving post-specific data, add the postId to the cache key, like this: `post_data_${postId})`. |
| `ttl`          | Time to live is the number of milliseconds the cached response is expected to be relevant.                                                                                                                                                                                                                                 |

Once it expires, the cached response will be voided and a real request is made to populate the cache again. You can treat it as a threshold, where ttl of 30000 would mean that a request is done no more than once per 30 seconds. |

## Example

Here’s a way to set up in-app caching instead of using scheduler or interval to fetch.

```tsx
import { Devvit, useState } from '@devvit/public-api';

Devvit.configure({
  redis: true,
  http: true, // to use `fetch()`
  // other capabilities
});

Devvit.addCustomPostType({
  name: 'Name',
  render: (context) => {
    const [data, setData] = useState({});

    async function getData() {
      const result = await context.cache(
        async () => {
          const response = await fetch('https://example.com');
          if (!response.ok) {
            throw Error(`HTTP error ${response.status}: ${response.statusText}`);
          }
          return await response.json();
        },
        {
          key: context.userId!,
          ttl: 10_000, // millis
        }
      );

      setData(result);
    }

    return (
      <blocks>
        <button
          onPress={() => {
            getData();
          }}
        >
          Load data
        </button>

        <text>{data.something}</text>
      </blocks>
    );
  },
});

export default Devvit;
```


# Forms

A form lets your app ask users to input and submit data. Forms can be defined with a simple [form object](#form-object) that takes a [list of fields](#supported-fields-types), and an [onSubmit handler](#on-submit-handler).

![A form dialog](../assets/capabilities/forms/forms-dialog.png)

## Using forms

There are several ways to add a form to your app, and the method you'll use depends on what you’re doing.

- For [interactive posts](#interactive-posts), use the `context.ui.useForm` hook.
- For [menu actions](#menu-actions), use the [`devvit.createForm`](/docs/api/public-api/classes/Devvit-1.md#createform) method.
- For [app configurations](#app-configurations), use the [`devvit.addSettings`](/docs/api/public-api/classes/Devvit-1.md#addsettings) method.

### Interactive posts

This example shows an interactive post with a text label and a button that triggers a form. When the form is submitted, the onSubmit handler takes the form input and manipulates state with [`useState`](/docs/working_with_usestate.md). The state update triggers a rerender and the new data is displayed.

```tsx
import { Devvit, useState, useForm } from '@devvit/public-api';

Devvit.addCustomPostType({
  name: 'TemplateName',
  render: (context) => {
    const [name, setName] = useState('unknown');

    const myForm = useForm(
      {
        fields: [
          {
            type: 'string',
            name: 'name',
            label: 'Name',
          },
        ],
      },
      (values) => {
        // onSubmit handler
        setName(values.name);
      }
    );

    return (
      <vstack gap="medium" height="100%" alignment="middle center">
        <text>Hello {name}!</text>
        <button
          onPress={() => {
            context.ui.showForm(myForm);
          }}
        >
          Set name
        </button>
      </vstack>
    );
  },
});

export default Devvit;
```

[Explore example in playground](https://developers.reddit.com/play#pen/N4IgdghgtgpiBcIBiB7ATlABASzJgogB4AOMa2MYAxjJgAooDOALiADQiNpUIjZTF0zTMEwARGADdJ2YQF9MAMzQosAcgACAEykzmAemIBXAEYAbbFQC0EYtjUBuADpgXE6bIB0ELVoDCRiyqDCwAKgCepAAUwC6YmJCw8JhqoTACZhDMMABy0DBqbHGYaJQ6aMlRVChg2YTMAJSYALwAfCLF8dVgLJgA2okwbJiMMMx5sAC6LZjddcyegTAAysxZMFFqRmAA1mAoAO5gag3OrnjxszW9UOGoGDNzMPWLo-dQUZ2XsReXl4oUMxaRjJPpfP7xH4Q6GYZiRGDJNQschgADmhXBMMGiMGGN+MPimRMMDMiImBSK+OhckpBMmtIhNMxUUkEDMRhgjCabQ6VMuo3G+RZbI5jE8g1OmLkX0l5z+pWYRjQeE+fIAPJIWBAqDtMKjbM0nCBYFpsEYoEbMAALGDYVFW5iGkAARgADK6AKSWtl2sCwWpOqDYXxmWg0WpkI2tTHxNXzVoACRJZhQIkGcgAhGr9PGY5g1SYjMxmDU8-EanRSoxGM1gFFue0oQTLk8XkZsJ5GFbDu8ord3rLm5g5NK+fFo2PLssxgl8nns4XizUJ9Ds5q1jqV5dB8PKXJZS5noI0MIdIoIEYzMJ3HoHOwQJIyIxsDUEM65EA).

### Menu actions

This example defines a new form and a onSubmit handler called `myForm` using the `devvit.createForm` method. This form is shown via a [menu action](./menu-actions.md) using `context.ui.showForm()`.

```ts
import { Devvit } from '@devvit/public-api';

const myForm = Devvit.createForm(
  {
    fields: [
      {
        type: 'string',
        name: 'food',
        label: 'What is your favorite food?',
      },
    ],
  },
  (event, context) => {
    // onSubmit handler
    context.ui.showToast({ text: event.values.food });
  }
);

Devvit.addMenuItem({
  label: 'Show a form',
  location: 'subreddit',
  onPress: async (_event, context) => {
    context.ui.showForm(myForm);
  },
});

export default Devvit;
```

### App configurations

For more details see the [app configurations page](./app-configurations.md).

## Form object

The form object enables you to customize the form container and the [list of form fields](#supported-fields-types) included. The form object is passed along to `context.ui.useForm`, [`devvit.createForm`](/docs/api/public-api/classes/Devvit-1.md#createform), or [`devvit.addSettings`](/docs/api/public-api/classes/Devvit-1.md#addsettings) to create the form.

#### Usage

```tsx
const myForm = {
  title: 'My form',
  description: 'This is my form. There are many like it, but this one is mine.',
  fields: [
    {
      type: 'string',
      name: 'food',
      label: 'What is your favorite food?',
    },
    {
      type: 'string',
      name: 'drink',
      label: 'What is your favorite drink?',
    },
  ],
  acceptLabel: 'Submit',
  cancelLabel: 'Cancel',
};
```

#### Supported properties

| Property      | Supported types      | Description                                   |
| :------------ | :------------------- | :-------------------------------------------- |
| `title`       | `string` `undefined` | An optional title for the form                |
| `description` | `string` `undefined` | An optional description for the form          |
| `fields`      | `FormField[]`        | The fields that will be displayed in the form |
| `acceptLabel` | `string` `undefined` | An optional label for the submit button       |
| `cancelLabel` | `string` `undefined` | An optional label for the cancel button       |

## onSubmit handler

When creating a form, you also specify a callback function that is called when the form is submitted. It takes two parameters: `event` and `context`. The `event` parameter contains the results of the form submission, while the `context` parameter represents the current app context of the form submission event.

```ts
const onSubmitHandler = (event, context) => {
  context.ui.showToast({ text: event.values.food });
};

const myForm = Devvit.createForm(
  {
    fields: [
      {
        type: 'string',
        name: 'food',
        label: 'What is your favorite food?',
      },
    ],
  },
  onSubmitHandler
);
```

:::note
Note: The `context` object is not available in onSubmit handlers within the `useForm` hook. For interactive posts, you already have access to the context element via the outer function's scope.
:::

## Supported fields types

The following field types are supported: [String](#string), [Select](#select), [Paragraph](#paragraph), [Number](#number), [Boolean](#boolean), and [Group](#group).

### String

A single-line text input.

![String input](../assets/capabilities/forms/forms-string.png)

#### Usage

```ts
const stringField = {
  type: 'string',
  name: 'title',
  label: 'Tournament title',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/docs/api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder`  | `string` `undefined`                                                              | Placeholder text for display before a value is present.                                                                                                          |
| `isSecret`     | `boolean` `undefined`                                                             | Makes the form field secret.                                                                                                                                     |

### Select

A dropdown menu with predefined options.

![Select input](../assets/capabilities/forms/forms-select.png)

#### Usage

```ts
const selectField = {
  type: 'select',
  name: 'interval',
  label: 'Update the leaderboard',
  options: [
    { label: 'Hourly', value: 'hourly' },
    { label: 'Daily', value: 'daily' },
    { label: 'Weekly', value: 'weekly' },
    { label: 'Monthly', value: 'monthly' },
    { label: 'Yearly', value: 'yearly' },
  ],
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `options`      | `FieldConfig_Selection_Item[]`                                                    | The list of options available.                                                                                                                                   |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` string[]` `undefined`                                                           | The default value of the field. Note that the default value is wrapped in an array to support multiple selected values.                                          |
| `scope`        | [`SettingScopeType`](/docs/api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `multiSelect`  | `boolean` `undefined`                                                             | Enables users to select more than 1 item from the set.                                                                                                           |

### Paragraph

A multi-line text input for longer responses.

![Paragraph input](../assets/capabilities/forms/forms-paragraph.png)

#### Usage

```ts
const paragraphField = {
  type: 'paragraph',
  name: 'description',
  label: 'Description',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/docs/api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder`  | `string` `undefined`                                                              | Placeholder text for display before a value is present.                                                                                                          |
| `lineHeight`   | `number` `undefined`                                                              | Sets the field height by number of lines.                                                                                                                        |

### Number

An input for numerical values.

![Number input](../assets/capabilities/forms/forms-number.png)

#### Usage

```ts
const numberField = {
  type: 'number',
  name: 'tokens',
  label: 'Token balance',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/docs/api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |

### Boolean

A yes/no or true/false type input.

![Boolean input](../assets/capabilities/forms/forms-boolean.png)

#### Usage

```ts
const booleanField = {
  type: 'boolean',
  name: 'enable',
  label: 'Enable the event',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/docs/api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |

### Image

An image upload field.

![Image input](../assets/capabilities/forms/forms-image.png)

#### Usage

```ts
const imageField = {
  type: 'image', // This tells the form to expect an image
  name: 'myImage',
  label: 'Image goes here',
  required: true,
};
```

#### Properties

| Property      | Supported types                                                                | Description                                                                                                                                                      |
| :------------ | :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`        | `string`                                                                       | The desired field type.                                                                                                                                          |
| `name`        | `string`                                                                       | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`       | `string`                                                                       | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`    | `string` `undefined`                                                           | An optional help text that will be displayed below the field.                                                                                                    |
| `required`    | `boolean` `undefined`                                                          | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`    | `boolean` `undefined`                                                          | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `scope`       | [`SettingScopeType`](../api/public-api/README.md#settingscopetype) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder` | `string` `undefined`                                                           | Placeholder text for display before a value is present.                                                                                                          |
| `isSecret`    | `boolean` `undefined`                                                          | Makes the form field secret.                                                                                                                                     |

### Group

A collection of related fields that allows for better readability.

#### Usage

```ts
const groupField = {
  type: 'group',
  label: 'This is a group of input fields',
  fields: [
    {
      type: 'paragraph',
      name: 'description',
      label: 'How would you describe what happened?',
    },
    {
      type: 'number',
      name: 'score',
      label: 'How would you rate your meal on a scale from 1 to 10?',
    },
  ],
};
```

#### Properties

| Property   | Supported types      | Description                                                   |
| :--------- | :------------------- | :------------------------------------------------------------ |
| `type`     | `string`             | The desired field type.                                       |
| `label`    | `string`             | The label of the group that will be displayed to the user.    |
| `fields`   | `FormField[]`        | The fields that will be displayed in the group.               |
| `helpText` | `string` `undefined` | An optional help text that will be displayed below the group. |

## Examples

Below is a collection of common use cases and patterns.

### Dynamic forms

Instead of passing a static Form, you can create a function that returns a Form. This enables us to dynamically determine which fields to show and what default values to populate them with. We can also pass along any data via the `context.ui.showForm` method's optional 2nd argument.

```tsx
import { Devvit } from '@devvit/public-api';

Devvit.configure({
  redditAPI: true,
});

const myForm = Devvit.createForm(
  (data) => {
    return {
      fields: [
        {
          type: 'string',
          name: 'username',
          label: 'Username',
          defaultValue: data.username,
        },
      ],
      // Adding `as const` helps you get accurate types in the onSubmit function below
      // This will only work if the function does not have any branching logic
    } as const;
  },
  (event, context) => {
    context.ui.showToast({
      text: `Hello ${event.values.username}`,
    });
  }
);

Devvit.addMenuItem({
  label: 'Show a dynamic form',
  location: 'subreddit',
  onPress: async (_event, context) => {
    const user = await context.reddit.getCurrentUser();
    const username = user?.username;
    context.ui.showForm(myForm, { username });
  },
});

export default Devvit;
```

### One of everything

This example includes one of each of the [supported field types](#supported-fields-types).

```tsx
import { Devvit } from '@devvit/public-api';

const exampleForm = Devvit.createForm(
  {
    title: 'My favorites',
    description: 'Tell us about your favorite food!',
    fields: [
      {
        type: 'string',
        name: 'food',
        label: 'What is your favorite food?',
        helpText: 'Must be edible',
        required: true,
      },
      {
        label: 'About that food',
        type: 'group',
        fields: [
          {
            type: 'number',
            name: 'times',
            label: 'How many times a week do you eat it?',
            defaultValue: 1,
          },
          {
            type: 'paragraph',
            name: 'what',
            label: 'What makes it your favorite?',
          },
          {
            type: 'select',
            name: 'healthy',
            label: 'Is it healthy?',
            options: [
              { label: 'Yes', value: 'yes' },
              { label: 'No', value: 'no' },
              { label: 'Maybe', value: 'maybe' },
            ],
            defaultValue: ['maybe'],
          },
        ],
      },
      {
        type: 'boolean',
        name: 'again',
        label: 'Can we ask again?',
      },
    ],
    acceptLabel: 'Submit',
    cancelLabel: 'Cancel',
  },
  (event, context) => {
    console.log(event.values);
    context.ui.showToast('Thanks!');
  }
);

Devvit.addMenuItem({
  location: 'subreddit',
  label: 'One of everything form',
  onPress: (_event, context) => {
    context.ui.showForm(exampleForm);
  },
});

export default Devvit;
```

### Multi-step forms

Add a multi-step dynamic form to an interactive post

```tsx
import { Devvit, useState, useForm } from '@devvit/public-api';

Devvit.configure({
  redditAPI: true,
});

Devvit.addCustomPostType({
  name: 'Multi-step Form',
  render: (context) => {
    const [name, setName] = useState('');
    const [food, setFood] = useState('');
    const [drink, setDrink] = useState('');

    const form3 = useForm(
      {
        fields: [
          {
            type: 'string',
            name: 'drink',
            label: "What's your favorite drink?",
            required: true,
          },
        ],
      },
      (values) => {
        setDrink(values.drink);
      }
    );

    const form2 = useForm(
      {
        fields: [
          {
            type: 'string',
            name: 'food',
            label: "What's your favorite food?",
            required: true,
          },
        ],
      },
      (values) => {
        setFood(values.food);
        context.ui.showForm(form3);
      }
    );

    const form1 = useForm(
      {
        fields: [
          {
            type: 'string',
            name: 'name',
            label: "What's your name?",
            required: true,
          },
        ],
      },
      (values) => {
        setName(values.name);
        context.ui.showForm(form2);
      }
    );

    function restart() {
      setName('');
      setFood('');
      setDrink('');
      context.ui.showForm(form1);
    }

    const isAnswered = name && food && drink;

    return (
      <vstack height="100%" alignment="center middle" gap="none">
        {isAnswered && (
          <>
            <text>Name: {name}</text>
            <text>Favorite food: {food}</text>
            <text>Favorite drink: {drink}</text>
            <spacer size="large" />
            <button onPress={restart}>Restart</button>
          </>
        )}
        {!isAnswered && <button onPress={restart}>Take questionnaire</button>}
      </vstack>
    );
  },
});

Devvit.addMenuItem({
  location: 'subreddit',
  label: 'Add post with multi-step form',
  onPress: async (_event, context) => {
    const currentSubreddit = await context.reddit.getCurrentSubreddit();
    await context.reddit.submitPost({
      title: 'Interactive post with multi-step form',
      subredditName: currentSubreddit.name,
      preview: (
        <vstack width="100%" height="100%" alignment="middle center">
          <text>Loading ...</text>
        </vstack>
      ),
    });
    context.ui.showToast('Submitted post!');
  },
});

export default Devvit;
```

[Explore example in a playground](https://developers.reddit.com/play#pen/N4IgdghgtgpiBcICyBXANgFwJYFoDOGMADgAQBmA9gE5QlZgkwAeRMVWMYAxjCURQRAAaEHipcEILFH5UMJYCQAiMAG6qs8gL7kqFWgHIAAgBM1GjAHoiKAEZosXHBCJYDAbgA6YbyvWaAOi4KMDIsAHMUKhgACmBvEhJokxNNAEEABQBJeBIMKhQYIW8tAEovHzA-CwCIFIBhFAJ9DIEMABUAT1Y4hJJIWFyDVExcAmISADFqKANihiTOMypcmOCwQiYMUpIAXgA+BT7E9YISAG0BopI8GAwAOWgYAF09knXNjACmmABlDAghBiBgM5WO7xCZ3OlAoJiENzu01hr12EI2zC+P3+gNiILBCxOkPk5xM7DAAGt4bcMEoyeSUWjPt9btigXiKuDTvJKDQAMxvD4Y5kwaY0GLgxLxAmJGVhGBoEx4XLnCUyyWqtWJDDdGBDAhk8JzDWaq5DUn0clG6WamVoCC2eW5TwgADqAAtAQY8CROhQouQIKpqJpeOaKQB+Z3zG026IARxQWGSuXyhWjMcSWnTNue2ZlWdVMVUEDQhTwOwOR2tMuptItRZLZYCYfJ+JtWnB+M5RPIMwATAKQkyfqKoOLq1KM3KFUqLsb1dWbdrWHr8vRDXmM6aSAYYSYrRm1XaHWgna6PRgvT6-VQA0H2IRe7DI8J5zL44nk3kCkU3wXFyQuaqv+NoNqWMDlnshyTjG1JIiYYFNnubYxoKWzfFgAR4G6FAAO6jjEPJQLyKFqh20pdtKXK9jQACMg7ouhI4zOONowTa06Ksqb7sYey66ju+rrgeh6JNuBhXCJonHo6JDOu6nrer6-pXC+m4xh+SYwCYKY-upZH6YB6kgZqiEQRW0HGtSjywGZeABFcpGamhmKYdheEEURfZOZmnYctKZAoNw2AhIsBAQHIMQ7LxiTWU8wKghUNpwRQsIJT5CI0nS6VJc5Q5ComWE4fhLFEbRTnkd2YBnFgeBpNVuFsNpbxXCQABkbVPiY7WdS2-lqtEGBRAwrGagAPKo4VcOSJBujAERuhguzOrRAAMq0AKTOiQJYRGAsAbMtIA8Oit5QFgKRoDA23hC4R1gCE10gPsxrALV9V4I1yQ9SQo0ZmNL0AWqY2fPsNkCcAVxaGNlig2+iQgxi+yTIGwaPnuuTAHu0Ow0j8MkIjWzI6jD6hnSmMtjjcNAzKY14EQEA8LeeBYAAXjAR12lQ4RPSQliA6JCO2CgGAYKFIQZNEeB4LswBSwCchaPsABKEEKxgMPC6LIQC4eMO6zapTkRmwAAITvQ1TXdR1BNa2LDAS1LMty2rEUYEr7QQOSvAJmrWAhJAWmayL9v7Mb42WJNALTQbJAof+ZT+cwsjyGYZAQOg8jVJoFTCCAqhsCzIQILRWhAA).

### Image uploads

Add an image upload input to a form.

```tsx
import { Devvit } from '@devvit/public-api';

const form = Devvit.createForm(
  {
    title: 'Upload an image!',
    fields: [
      {
        name: 'myImage',
        type: 'image', // This tells the form to expect an image
        label: 'Image goes here',
        required: true,
      },
    ],
  },
  (event, context) => {
    const imageUrl = event.values.myImage;
    // Use the mediaUrl to store in redis and display it in an <image> block, or send to external service to modify
  }
);
```


# HTTP fetch

Make requests to allow-listed external domains.

Your Devvit app can make network requests to access allow-listed external domains using HTTP Fetch. This enables your app to leverage webhooks, personal servers, and other third-party integrations asynchronously across the network.

## Devvit configure

```ts
import { Devvit } from '@devvit/public-api';

Devvit.configure({
  http: true,
  // other capabilities
});
```

## Limitations

- Access is only allowed to https URIs.
- Supported HTTP methods: `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS` and `PATCH`.
- HTTP timeout limit is 30 seconds.

To request a domain to the allow-list, [please contact us via r/devvit modmail](https://www.reddit.com/message/compose/?to=r%2Fdevvit) or fill out [this form](https://forms.gle/Pn8Eq3RoPcmH1ZJJ7).

## Example

```ts
import { Devvit } from '@devvit/public-api';

Devvit.configure({ http: true });

Devvit.addMenuItem({
  location: 'comment',
  label: 'Sample HTTP request',
  onPress: async (_, context) => {
    console.log(`Comment ID:  ${context.commentId}`);
    const response = await fetch('https://example.com', {
      method: 'post',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content: context.commentId }),
    });
    context.ui.showToast(
      `Invoked HTTP request on comment: ${context.commentId}. Completed with status: ${response.status}`
    );
  },
});

export default Devvit;
```

## Troubleshooting

If you see the following error, it means HTTP Fetch requests are hitting the internal timeout limits. To resolve this:

- Use a queue or kick off an async request in your back end. You can use [Scheduler](/docs/capabilities/scheduler.md) to monitor the result.
- Optimize the overall HTTP request latency if you have a self-hosted server.

```ts
HTTP request to domain: <domain> timed out with error: context deadline exceeded.
```

### Terms and Conditions

Any app that uses `fetch` must upload Terms and Conditions and a Privacy Policy. Links to each of these documents must be saved in the app details form.

![App configuration form](../assets/capabilities/http-fetch/http-fetch-legal-links.png)




# Image uploads

Include images that are 20 MB or less in your app.

You can embed the image in a post or comment and use rich-text builder to format the text heading, paragraph, code block, and more. There are two ways to upload an image: using a template or starting from scratch.

## How to use image upoads

:::note
You can copy this [template](https://github.com/reddit/devvit/tree/main/packages/cli/src/templates/image-uploads) using image-upload.
:::

1. From the terminal, navigate to a directory where you'd like to store your code.
2. Enter the following command to create the app.

```ts
devvit new <your-app-name>
```

3. Configure `Devvit` to allow media

```ts
Devvit.configure({
  media: true,
  // other capabilities
});
```

4. Use `context.media.upload()` to upload images/gifs to your app.

```ts
await context.media.upload({
  url: 'https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif',
  type: 'gif',
});
```

You can use the code snippet below as a starting point:

<details><summary>Code example</summary>

```ts
import { Devvit, RichTextBuilder } from '@devvit/public-api';

Devvit.configure({ media: true, redditAPI: true });

Devvit.addMenuItem({
  location: 'comment',
  label: 'Reply with GIF',
  onPress: async (event, context) => {
    console.log(`Invoked action on comment ${event.targetId}`);
    try {
      const response = await context.media.upload({
        url: 'https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif',
        type: 'gif',
      });
      await context.reddit.submitComment({
        id: event.targetId, // where context menu action was invoked
        text: 'Hello World with Media',
        richtext: new RichTextBuilder()
          .image({ mediaId: response.mediaId })
          .codeBlock({}, (cb) => cb.rawText('This comment was created from a Devvit App')),
      });
    } catch (err) {
      throw new Error(`Error uploading media: ${err}`);
    }
  },
});

export default Devvit;
```

</details>

## Test your app

Use `devvit upload` to check your app in a test subreddit.

# Menu actions

Add an item to the three dot menu.

You can add custom menu actions to posts and comments using the `Devvit.addMenuItem()` function.

:::note
On new Reddit, comment menu actions in modqueue are only available in card view.
:::

![Subreddit menu actions](../assets/capabilities/menu-actions/menu-actions-subreddit.png)

## Supported Contexts

You can decide where the menu action shows up by specifying the context property. For example, setting the location to ‘comment’ will only show the menu action on comments.

| Property               | Values                         | Description                                                                     |
| ---------------------- | ------------------------------ | ------------------------------------------------------------------------------- |
| location (required)    | `comment`, `post`, `subreddit` | Determines where the menu action appears in the custom post.                    |
| postFilter (optional)  | `currentApp`                   | Shows the action created by your app. The default is no filtering.              |
| forUserType (optional) | `moderator`                    | Specifies the user types that can see the menu action. The default is everyone. |

:::note
For moderator permission security, when opening a form from a menu action with `forUserType: moderator`, the user initiating the action must complete all actions within 10 minutes.
:::

## Limitations

- A sort order of actions in the context menu can't be specified.
- The context, name, and description fields do not support dynamic logic.

## Example

This example uses `Devvit.addMenuItem()` to create menu actions for comments, posts and subreddits.

```ts
import { Devvit } from '@devvit/public-api';

// Declare multiple actions to be added to the menu
Devvit.addMenuItem({
  label: 'Say Hello',
  location: 'post', // accepts 'post', 'comment', 'subreddit', or a combination as an array
  forUserType: 'moderator', // restricts this action to moderators, leave blank for any user
  onPress: (event, context) => {
    context.ui.showToast(`Hello from a ${event.location}!`);
  },
});
```

# Realtime

Create live and event-driven interactive posts. Realtime provides a set of primitives that lets you build interactive posts that are:

- **Live**. Users engaging with the same interactive post see each others’ changes without any observable lag.
- **Event-driven**. Posts render automatically in response to server events.
- **Synced**. Using realtime with [Redis](/docs/capabilities/redis.md) lets you build persistent community experiences that are backed by high performance data synchronization.

## Create a live interactive post

#### 1. Configure realtime.

```tsx
Devvit.configure({
  realtime: true,
});
```

#### 2. Create and subscribe to a channel.

`useChannel` hook allows interactive posts to subscribe and send to an event stream.

A new channel can be setup with function handlers containing custom logic to update state:

- `onMessage` - called every time a message is received on a channel
- `onSubscribed` - optional hook to be informed when channel has connected
- `onUnsubscribed` - optional hook to be informed when channel has disconnected

```tsx
import { Devvit, useChannel } from '@devvit/public-api';

// Defined within render function of an interactive post

// Choose a channel name that works for you

// You have the flexibility to define the message data shape to be published
// via channel.send - same shape will be received in the onMessage handler

const channel = useChannel({
  name: 'events',
  onMessage: (data) => {
    // modify local state
  },
  onSubscribed: () => {
    // handle connection setup
  },
  onUnsubscribed: () => {
    // handle network degradation with fallback scenarios
  },
});

// subscribe to the channel to receive messages
channel.subscribe();
```

#### 3. Send messages to a channel.

`channel.send` is recommended for peer-to-peer synchronization across clients. See [Mini Place](#mini-place) and [Snoo Club](#snoo-club)

```tsx
<button
  icon="add-fill"
  width={50}
  onPress={async () => {
    const newProgress = Math.max(progress + 10, 0);
    const message: RealtimeMessage = {
      payload: { progress: newProgress },
      session: UUID,
    };
    setProgress(newProgress); // set local state
    await channel.send(message); // publish message to the channel
  }}
/>
```

`realtime.send` is recommended for re-rendering interactive posts based on server events. This can be invoked on an event trigger, scheduled job, or after a HTTP fetch call. [Server-Push](#server-push) example illustrates how to compose scheduler and realtime together.

```tsx
// During app installation, we create a scheduled job 'publish_to_channel' that runs
// every minute - it uses realtime plugin to publish events to an arbitrary channel

Devvit.addTrigger({
  event: 'AppInstall',
  onEvent: async (_, context) => {
    await context.scheduler.runJob({
      name: 'publish_to_channel',
      cron: '* * * * *',
    });
  },
});

// Interactive posts subscribed to the 'events' channel via useChannel hook will start
// receiving messages which can processed in the onMessage handler to update local state.
Devvit.addSchedulerJob({
  name: 'publish_to_channel',
  onRun: async (_, context) => {
    await context.realtime.send('events', {
      message: payload,
    });
  },
});
```

## Limits and Quotas

- Messages/sec per installation: 100
- Maximum message payload: 1 MB
- Channels per app installation: 5

## Examples

:::note
Try the demos with multiple browser windows and see local changes sync across sessions without any lag.
:::

### Mini Place

![mini_place_high](../assets/realtime/mini_place_high.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bumd7e/mini_place/)**,
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/mini-place)**

### Snoo Club

![snoo_club](../assets/realtime/snoo_club.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bunpzv/interactive_snooclub/)**,
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/snooclub)**

### Synced Progress Bar

![synced_progress_bar](../assets/realtime/synced_progress_bar.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1b3ccp9/synced_progress_bar/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/synced-progress-bar)**

### Devvit Emoji Chat

![devvit_emoji_chat](../assets/realtime/devvit_emoji_chat.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bvf6if/emoji_chat/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/devvit-emoji-chat)**

### Server Push

![server_push](../assets/realtime/server_push.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bnnc60/server_push/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/server-push)**


# Redis

You can add a database to your app to store and retrieve data. The Redis plugin is designed to be fast, scalable, and secure. It supports a subset of the full Redis API, including:

- [Transactions](#transactions) for things like counting votes atomically in polls
- [String operations](#strings) for persisting information
- [Number operations](#numbers) for incrementing numbers
- [Sorted sets](#sorted-set) for creating leaderboards
- [Hashes](#hash) for managing a collection of key-value pairs
- [Bitfields](#bitfield) for efficient operation on sequences of bits

Each app version installed on a subreddit is namespaced, which means Redis data is siloed from other subreddits. Keep in mind that there won’t be a single source of truth for all installations of your app, since each app installation can only access the data that it has stored in the Redis database.

## Limits and Quotas

- Max commands per second: 1000
- Max request size: 5 MB
- Max storage: 500 MB

All limits are applied at a per-installation granularity.

## Examples

### Menu items

```tsx
Devvit.addMenuItem({
  location: 'subreddit',
  label: 'Test Redis',
  onPress: async (event, { redis }) => {
    const key = 'hello';
    await redis.set(key, 'world');
    const value = await redis.get(key);
    console.log(`${key}: ${value}`);
  },
});
```

### Interactive posts

You can copy this [template](https://github.com/reddit/devvit/tree/main/packages/cli/src/templates/redis) to create an interactive post containing an interactive progress bar backed by Redis.

## Supported Redis commands

:::note
Not all Redis features are supported. If you would like to request a specific Redis feature, please reach out to our team [via modmail](https://www.reddit.com/message/compose/?to=%2Fr%2FDevvit) or Discord.
:::

### Simple read/write

| **Command**                                | **Action**                                                            |
| ------------------------------------------ | --------------------------------------------------------------------- |
| [get](https://redis.io/commands/get)       | Gets the value of key.                                                |
| [set](https://redis.io/commands/set)       | Sets key to hold a string value.                                      |
| [exists](https://redis.io/commands/exists) | Returns number of given keys that exist.                              |
| [del](https://redis.io/commands/del)       | Removes the specified keys.                                           |
| [type](https://redis.io/commands/type)     | Returns the string representation of the type of value stored at key. |
| [rename](https://redis.io/commands/rename) | Renames a key.                                                        |

<details><summary>Code Example</summary>

```tsx
async function simpleReadWriteExample(context: Devvit.Context) {
  // Set a key
  await context.redis.set('color', 'red');

  // Check if a key exists
  console.log('Key exists: ' + (await context.redis.exists('color')));

  // Get a key
  console.log('Color: ' + (await context.redis.get('color')));

  // Get the type of a key
  console.log('Type: ' + (await context.redis.type('color')));

  // Delete a key
  await context.redis.del('color');
}
```

```bash
Color: red
Type: string
```

</details>

### Batch read/write

| **Command**                            | **Action**                                      |
| -------------------------------------- | ----------------------------------------------- |
| [mGet](https://redis.io/commands/mget) | Returns the values of all specified keys.       |
| [mSet](https://redis.io/commands/mset) | Sets the given keys to their respective values. |

<details><summary>Code Example</summary>

```tsx
async function batchReadWriteExample(context: Devvit.Context) {
  // Set multiple keys at once
  await context.redis.mSet({
    name: 'Devvit',
    occupation: 'Developer',
    yearsOfExperience: '9000',
  });

  // Get multiple keys
  console.log('Result: ' + (await context.redis.mGet(['name', 'occupation'])));
}
```

```bash
Result: Devvit,Developer
```

</details>

### Strings

| **Command**                                    | **Action**                                                                                                             |
| ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| [getRange](https://redis.io/commands/getrange) | Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive). |
| [setRange](https://redis.io/commands/setrange) | Overwrites part of the string stored at key, starting at the specified offset, for the entire length of value.         |
| [strLen](https://redis.io/commands/strlen)     | Returns the length of the string value stored at key.                                                                  |

<details><summary>Code Example</summary>

```tsx
async function stringsExample(context: Devvit.Context) {
  // First, set 'word' to 'tacocat'
  await context.redis.set('word', 'tacocat');

  // Use getRange() to get the letters in 'word' between index 0 to 3, inclusive
  console.log('Range from index 0 to 3: ' + (await context.redis.getRange('word', 0, 3)));

  // Use setRange() to insert 'blue' at index 0
  await context.redis.setRange('word', 0, 'blue');

  console.log('Word after using setRange(): ' + (await context.redis.get('word')));

  // Use strLen() to verify the word length
  console.log('Word length: ' + (await context.redis.strLen('word')));
}
```

```bash
Range from index 0 to 3: taco
Word after using setRange(): bluecat
Word length: 7
```

</details>

### Hash

Redis hashes can store up to ~ 4.2 billion key-value pairs. We recommend using hash for managing collections of key-value pairs whenever possible and iterating over it using a combination of `hscan`, `hkeys` and `hgetall`.

| **Command**                                   | **Action**                                                                        |
| --------------------------------------------- | --------------------------------------------------------------------------------- |
| [hGet](https://redis.io/commands/hget)        | Returns the value associated with field in the hash stored at key.                |
| [hMGet](https://redis.io/commands/hmget)      | Returns the value of all specified field in the hash stored at multiple keys.     |
| [hSet](https://redis.io/commands/hset/)       | Sets the specified fields to their respective values in the hash stored at key.   |
| [hSetNX](https://redis.io/commands/hsetnx/)   | Sets field in the hash stored at key to value, only if field does not yet exist.ƒ |
| [hDel](https://redis.io/commands/hdel/)       | Removes the specified fields from the hash stored at key.                         |
| [hGetAll](https://redis.io/commands/hgetall/) | Returns a map of fields and their values stored in the hash.                      |
| [hKeys](https://redis.io/commands/hkeys/)     | Returns all field names in the hash stored at key.                                |
| [hScan](https://redis.io/commands/hscan/)     | Iterates fields of Hash types and their associated values.                        |
| [hIncrBy](https://redis.io/commands/hincrby/) | Increments the score of member in the sorted set stored at key by value.          |
| [hLen](https://redis.io/commands/hlen/)       | Returns the number of fields contained in the hash stored at key.                 |

<details><summary>Code Examples</summary>

**Example 1**

```tsx
// Example using hGet(), hSet(), and hDel()
async function hashExample1(context: Devvit.Context) {
  // Set 'inventory' with multiple fields and values
  await context.redis.hSet('inventory', {
    sword: '1',
    potion: '4',
    shield: '2',
    stones: '8',
  });

  // Get the value of 'shield' from 'inventory'
  console.log('Shield count: ' + await context.redis.hGet('inventory', 'shield'));

  // Get the values of both of 'shield' and 'potion' from 'inventory'
  console.log('Shield and potion count: ' + await context.redis.hMGet('inventory', ['shield', 'potion']));

  // Delete some fields from 'inventory'
  console.log(
    'Number of fields deleted: ' +
      await context.redis.hDel('inventory', ['sword', 'shield', 'stones']);
  );
}
```

```bash
Shield count: 2
Shield and potion count: 2,4
Number of fields deleted: 3
```

---

**Example 2**

```tsx
// Example using hGetAll()
async function hashExample2(context: Devvit.Context) {
  // Set 'groceryList' to fields containing products with quantities
  await context.redis.hSet('groceryList', {
    eggs: '12',
    apples: '3',
    milk: '1',
  });

  // Get the groceryList record
  const record = await context.redis.hGetAll('groceryList');

  if (record != undefined) {
    console.log('Eggs: ' + record.eggs + ', Apples: ' + record.apples + ', Milk: ' + record.milk);
  }
}
```

```bash
Eggs: 12, Apples: 3, Milk: 1
```

---

**Example 3**

```tsx
// Example using hKeys()
async function hashExample3(context: Devvit.Context) {
  await context.redis.hSet('prices', {
    chair: '48',
    desk: '95',
    whiteboard: '23',
  });

  console.log('Keys: ' + (await context.redis.hKeys('prices')));
}
```

```bash
Keys: chair,desk,whiteboard
```

---

**Example 4**

```tsx
// Example using hScan()
async function hashExample4(context: Devvit.Context) {
  await context.redis.hSet('userInfo', {
    name: 'Bob',
    startDate: '01-05-20',
    totalAwards: '12',
  });

  // Scan and interate over all the fields within 'userInfo'
  const hScanResponse = await context.redis.hScan('userInfo', 0);

  hScanResponse.fieldValues.forEach((x) => {
    console.log("Field: '" + x.field + "', Value: '" + x.value + "'");
  });
}
```

```bash
Field: 'name', Value: 'Bob'
Field: 'totalAwards', Value: '12'
Field: 'startDate', Value: '01-05-20'
```

---

**Example 5**

```tsx
// Example using hIncrBy()
async function hashExample5(context: Devvit.Context) {
  // Set user123's karma to 100
  await context.redis.hSet('user123', { karma: '100' });

  // Increase user123's karma by 5
  console.log('Updated karma: ' + (await context.redis.hIncrBy('user123', 'karma', 5)));
}
```

```bash
Updated karma: 105
```

---

**Example 6**

```tsx
// Example using hLen()
async function hashExample6(context: Devvit.Context) {
  await context.redis.hSet('supplies', {
    paperclips: '25',
    pencils: '10',
    erasers: '5',
    pens: '7',
  });

  console.log('Number of fields: ' + (await context.redis.hLen('supplies')));
}
```

```bash
Number of fields: 4
```

</details>

### Numbers

| **Command**                                | **Action**                                        |
| ------------------------------------------ | ------------------------------------------------- |
| [incrBy](https://redis.io/commands/incrby) | Increments the number stored at key by increment. |

<details><summary>Code Example</summary>

```tsx
async function numbersExample(context: Devvit.Context) {
  await context.redis.set('totalPoints', '53');

  console.log('Updated points: ' + (await context.redis.incrBy('totalPoints', 100)));
}
```

```bash
Updated points: 153
```

</details>

### Key expiration

| **Command**                                         | **Action**                                                        |
| --------------------------------------------------- | ----------------------------------------------------------------- |
| [expire](https://redis.io/commands/expire/)         | Sets a timeout on key.                                            |
| [expireTime](https://redis.io/commands/expiretime/) | Returns the remaining seconds at which the given key will expire. |

<details><summary>Code Example</summary>

```tsx
async function keyExpirationExample(context: Devvit.Context) {
  // Set a key 'product' with value 'milk'
  await context.redis.set('product', 'milk');

  // Get the current expireTime for the product
  console.log('Expire time: ' + (await context.redis.expireTime('product')));

  // Set the product to expire in 60 seconds
  await context.redis.expire('product', 60);

  // Get the updated expireTime for the product
  console.log('Updated expire time: ' + (await context.redis.expireTime('product')));
}
```

```bash
Expire time: 0
Updated expire time: 60
```

</details>

### [Transactions](https://redis.io/topics/transactions)

Redis transactions allow a group of commands to be executed in a single isolated step. For example, to implement voting action in a polls app, these three actions need to happen together:

- Store the selected option for the user.
- Increment the count for selected option.
- Add the user to voted user list.

The `watch` command provides an entrypoint for transactions. It returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which can be used to call `multi`, `exec`, `discard`, `unwatch`, and all other Redis commands to be executed within a transaction.

You can sequence all of the above steps in a single transaction using `multi` and `exec` to ensure that either all of the steps happen together or none at all.

If an error occurs inside a transaction before `exec` is called, Redis discards the transaction automatically. See the Redis docs: [Errors inside a transaction](https://redis.io/docs/latest/develop/interact/transactions/#errors-inside-a-transaction) for more info.

| **Command**                                   | **Action**                                                                                                                                                                                                                                      |
| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [multi](https://redis.io/commands/multi/)     | Marks the start of a transaction block.                                                                                                                                                                                                         |
| [exec](https://redis.io/commands/exec/)       | Executes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                           |
| [discard](https://redis.io/commands/discard/) | Flushes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                            |
| [watch](https://redis.io/commands/watch/)     | Marks the given keys to be watched for conditional execution of a transaction. `watch` returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which should be used to call Redis commands in a transaction. |
| [unwatch](https://redis.io/commands/unwatch/) | Flushes all the previously watched keys for a transaction.                                                                                                                                                                                      |

<details><summary>Code Examples</summary>

**Example 1**

```tsx
// Example using exec()
async function transactionsExample1(context: Devvit.Context) {
  await context.redis.mSet({ quantity: '5', karma: '32' });

  const txn = await context.redis.watch('quantity');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('karma', 10);
  await txn.set('name', 'Devvit');
  await txn.exec(); // Execute the commands in the transaction

  console.log(
    'Keys after completing transaction: ' +
      (await context.redis.mGet(['quantity', 'karma', 'name']))
  );
}
```

```bash
Keys after completing transaction: 5,42,Devvit
```

---

**Example 2**

```tsx
// Example using discard()
async function transactionsExample2(context: Devvit.Context) {
  await context.redis.set('price', '25');

  const txn = await context.redis.watch('price');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('price', 5);
  await txn.discard(); // Discard the commands in the transaction

  console.log('Price value: ' + (await context.redis.get('price'))); // 'price' should still be '25'
}
```

```bash
Price value: 25
```

---

**Example 3**

```tsx
// Example using unwatch()
async function transactionsExample3(context: Devvit.Context) {
  await context.redis.set('gold', '50');

  const txn = await context.redis.watch('gold');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('gold', 30);
  await txn.unwatch(); // Unwatch "gold"

  // Now that "gold" has been unwatched, we can increment its value
  // outside the transaction without canceling the transaction
  await context.redis.incrBy('gold', -20);

  await txn.exec(); // Execute the commands in the transaction

  console.log('Gold value: ' + (await context.redis.get('gold'))); // The value of 'gold' should be 50 + 30 - 20 = 60
}
```

```bash
Gold value: 60
```

</details>

### Sorted set

| **Command**                                                     | **Action**                                                                                                                                                                                                                                                      |
| --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [zAdd](https://redis.io/commands/zadd/)                         | Adds all the specified members with the specified scores to the sorted set stored at key.                                                                                                                                                                       |
| [zCard](https://redis.io/commands/zcard)                        | Returns the sorted set cardinality (number of elements) of the sorted set stored at key.                                                                                                                                                                        |
| [zRange](https://redis.io/commands/zrange/)                     | Returns the specified range of elements in the sorted set stored at key. <br><br> When using `by: 'lex'`, the start and stop inputs will be prepended with `[` by default, unless they already begin with `[`, `(` or are one of the special values `+` or `-`. |
| [zRem](https://redis.io/commands/zrem/)                         | Removes the specified members from the sorted set stored at key.                                                                                                                                                                                                |
| [zScore](https://redis.io/commands/zscore/)                     | Returns the score of member in the sorted set at key.                                                                                                                                                                                                           |
| [zRank](https://redis.io/commands/zrank/)                       | Returns the rank of member in the sorted set stored at key.                                                                                                                                                                                                     |
| [zIncrBy](https://redis.io/commands/zincrby/)                   | Increments the score of member in the sorted set stored at key by value.                                                                                                                                                                                        |
| [zScan](https://redis.io/commands/zscan/)                       | Iterates elements of sorted set types and their associated scores. Note that there is no guaranteed ordering of elements in the result.                                                                                                                         |
| [zRemRangeByLex](https://redis.io/commands/zremrangebylex/)     | When all elements in a sorted set are inserted with the same score, this command removes the elements at key between the lexicographical range specified by min and max.                                                                                        |
| [zRemRangeByRank](https://redis.io/commands/zremrangebyrank/)   | Removes all elements in the sorted set stored at key with rank between start and stop.                                                                                                                                                                          |
| [zRemRangeByScore](https://redis.io/commands/zremrangebyscore/) | Removes all elements in the sorted set stored at key with a score between min and max (inclusive).                                                                                                                                                              |

<details><summary>Code Examples</summary>

**Example 1**

```tsx
// Example using zRange() with by 'score'
async function sortedSetExample1(context: Devvit.Context) {
  await context.redis.zAdd(
    'leaderboard',
    { member: 'louis', score: 37 },
    { member: 'fernando', score: 10 },
    { member: 'caesar', score: 20 },
    { member: 'alexander', score: 25 }
  );

  // Cardinality should be '4' as there are 4 elements in the leaderboard set
  console.log('Cardinality: ' + (await context.redis.zCard('leaderboard')));

  // View elements with scores between 0 and 30 inclusive, sorted by score
  let scores = await context.redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Scores: ' + JSON.stringify(scores));

  // Remove 'fernando' from the leaderboard
  await context.redis.zRem('leaderboard', ['fernando']);

  // View the elements sorted by score again. This time 'fernando' should not appear in the output
  scores = await context.redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Updated scores: ' + JSON.stringify(scores));

  // View caesar's score
  console.log("Caesar's score: " + (await context.redis.zScore('leaderboard', 'caesar')));
}
```

```bash
Cardinality: 4
Scores: [{"score":10,"member":"fernando"},{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Updated scores: [{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Caesar's score: 20
```

---

**Example 2**

```tsx
// Example using zRange() with by 'lex'
async function sortedSetExample2(context: Devvit.Context) {
  await context.redis.zAdd(
    'checkpoints',
    { member: 'delta', score: 0 },
    { member: 'omega', score: 0 },
    { member: 'alpha', score: 0 },
    { member: 'charlie', score: 0 }
  );

  // View elements between the words 'alpha' and 'fox' inclusive, sorted lexicographically
  // Note that 'by: "lex"' only works if all elements have the same score
  const members = await context.redis.zRange('checkpoints', 'alpha', 'fox', { by: 'lex' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":0,"member":"alpha"},{"score":0,"member":"charlie"},{"score":0,"member":"delta"}]
```

---

**Example 3**

```tsx
// Example using zRange() with by 'rank'
async function sortedSetExample3(context: Devvit.Context) {
  await context.redis.zAdd(
    'grades',
    { member: 'sam', score: 80 },
    { member: 'norma', score: 95 },
    { member: 'alex', score: 77 },
    { member: 'don', score: 84 },
    { member: 'zeek', score: 92 }
  );

  // View elements with a rank between 2 and 4 inclusive. Note that ranks start at index 0.
  const members = await context.redis.zRange('grades', 2, 4, { by: 'rank' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":84,"member":"don"},{"score":92,"member":"zeek"},{"score":95,"member":"norma"}]
```

---

**Example 4**

```tsx
// Example using zRank() and zIncrBy()
async function sortedSetExample4(context: Devvit.Context) {
  await context.redis.zAdd(
    'animals',
    { member: 'zebra', score: 92 },
    { member: 'cat', score: 100 },
    { member: 'dog', score: 95 },
    { member: 'elephant', score: 97 }
  );

  // View the rank of 'dog' in the animals set
  // Rank should be '1' since 'dog' has the second lowest score. Note that ranks start at index 0.
  console.log("Dog's rank: " + (await context.redis.zRank('animals', 'dog')));

  // View the rank of 'zebra'
  console.log("Zebra's rank: " + (await context.redis.zRank('animals', 'zebra')));

  // Increase the score of 'dog' by 10
  await context.redis.zIncrBy('animals', 'dog', 10);

  // View the rank of 'dog' again. This time it should be '3' because dog has the highest score.
  console.log(
    "Dog's rank after incrementing score: " + (await context.redis.zRank('animals', 'dog'))
  );
}
```

```bash
Dog's rank: 1
Zebra's rank: 0
Dog's rank after incrementing score: 3
```

---

**Example 5**

```tsx
// Example using zRemRangeByLex()
async function sortedSetExample5(context: Devvit.Context) {
  await context.redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 0 },
    { member: 'mango', score: 0 },
    { member: 'banana', score: 0 },
    { member: 'orange', score: 0 },
    { member: 'apple', score: 0 }
  );

  // Remove fruits alphabetically ordered between 'kiwi' inclusive and 'orange' exclusive
  // Note: The symbols '[' and '(' indicate inclusive or exclusive, respectively. These must be included in the call to zRemRangeByLex().
  await context.redis.zRemRangeByLex('fruits', '[kiwi', '(orange');

  // Only 'apple', 'banana', and 'orange' should remain in the set
  const zScanResponse = await context.redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":0,"member":"apple"},{"score":0,"member":"banana"},{"score":0,"member":"orange"}]}
```

---

**Example 6**

```tsx
// Example using zRemRangeByRank()
async function sortedSetExample6(context: Devvit.Context) {
  await context.redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits ranked 1 through 3 inclusive
  await context.redis.zRemRangeByRank('fruits', 1, 3);

  // Only 'kiwi' and 'apple' should remain in the set
  const zScanResponse = await context.redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":50,"member":"apple"}]}
```

---

**Example 7**

```tsx
// Example using zRemRangeByScore() example
async function sortedSetExample7(context: Devvit.Context) {
  await context.redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits scored between 30 and 50 inclusive
  await context.redis.zRemRangeByScore('fruits', 30, 50);

  // Only 'kiwi' and 'mango' should remain in the set
  const zScanResponse = await context.redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":20,"member":"mango"}]}
```

</details>

### Bitfield

| **Command**                                                 | **Action**                                        |
| ----------------------------------------------------------- | ------------------------------------------------- |
| [bitfield](https://redis.io/docs/latest/commands/bitfield/) | Performs a sequence of operations on a bit string |

<details><summary>Code Example</summary>

```tsx
async function bitfieldExample(context: Devvit.Context) {
  const setBits: number[] = await context.redis.bitfield('foo', 'set', 'i5', '#0', 11);
  console.log('Set result: ' + setBits); // [0]

  const getBits: number[] = await context.redis.bitfield('foo', 'get', 'i5', '#0');
  console.log('Get result: ' + setBits); // [11]

  const manyOperations: number[] = await context.redis.bitfield(
    'bar',
    'set',
    'u2',
    0,
    3,
    'get',
    'u2',
    0,
    'incrBy',
    'u2',
    0,
    1,
    'overflow',
    'sat',
    'get',
    'u2',
    0,
    'set',
    'u2',
    0,
    3,
    'incrBy',
    'u2',
    0,
    1
  );
  console.log('Results of many operations: ' + manyOperations); // [0, 3, 0, 0, 3, 3]
}
```

```bash
fooResults: [1, 0]
barResults: [0, 3, 0, 0, 3, 3]
```

</details>

# Scheduler

Store and execute future actions.

Use the scheduler to do things like send a private message at a specified time, track upvotes, or schedule time-outs for user actions.

## Create a job

Create a job definition using `Devvit.addSchedulerJob` method.

```ts
Devvit.addSchedulerJob({
  name: 'thing-todo', // you can use an arbitrary name here
  onRun: async (event, context) => {
    // do stuff when the job is executed
  },
});
```

## Schedule the job

Use the `context.scheduler.runJob()` method to schedule the job you created. You can schedule the job to run once at at a particular time in the future or schedule it to be called repeatedly at a specific time.

- To schedule the job to run once, use the `runAt` parameter:

```ts
Devvit.addMenuItem({
  label: 'Remind me about this post',
  location: 'post',
  onPress: async (event, context) => {
    const jobId = await context.scheduler.runJob({
      name: 'thing-todo', // the name of the job that we specified in addSchedulerJob() above
      runAt: new Date('2099-01-01'),
    });
  },
});
```

Optionally, you can save the `jobId` in [Redis storage](./redis.md) to be able to [cancel the scheduled action](#cancel-an-action) in the future.

```ts
await context.redis.set('thing-todo:jobId', jobId);
```

- To schedule a recurring action, use a `cron` parameter:

:::note
`scheduler.runJob()` uses the same format that is used in UNIX `cron`, a command-line utility is a job scheduler on Unix-like operating systems https://en.wikipedia.org/wiki/Cron

```
# * * * * *
# | | | | |
# | | | | day of the week (0–6) Sunday to Saturday; 7 is also Sunday on some systems
# | | | month (1–12)
# | | day of the month (1–31)
# | hour (0–23)
# minute (0–59)
```

:::

```ts
Devvit.addMenuItem({
  label: 'Run every day',
  location: 'post',
  onPress: async (event, context) => {
    const jobId = await context.scheduler.runJob({
      name: 'thing-todo',
      cron: '0 12 * * *',
    });
  },
});
```

:::note
We recommend using [Cronitor](https://crontab.guru/) to build out strings.
:::

## Cancel an action

Use the job ID to cancel a scheduled action and remove it from your app.

```ts
Devvit.addMenuItem({
  label: 'clear',
  location: 'post',
  forUserType: 'moderator',
  onPress: async (_, context) => {
    const jobId = (await context.redis.get('jobId')) || '0';
    await context.scheduler.cancelJob(jobId);
  },
});

export default Devvit;
```

## Examples

### Schedule a one-off action

You can schedule an action to run once at a specific time, like sending a private message in the [Remind Me](/docs/showcase/tutorials/remind_me.md) tutorial.

```ts
import { Devvit } from '@devvit/public-api';

const REMIND_ME_ACTION_NAME = 'remindme';

Devvit.addSchedulerJob({
  name: REMIND_ME_ACTION_NAME,
  onRun: async (event, context) => {
    const { userId, postId, fromWhen } = event.data!;

    const user = await context.reddit.getUserById(userId);
    const post = await context.reddit.getPostById(postId);

    // Send a private message to the user
    await context.reddit.sendPrivateMessage({
      to: user.username,
      subject: 'RemindMe',
      text: `Beep boop! You asked me to remind you about [${post.title}](${post.permalink}) at ${fromWhen}!`,
    });
  },
});

Devvit.addMenuItem({
  label: 'Remind me about this post',
  location: 'post',
  onPress: async (event, context) => {
    // Code below could also be run from another capability, like an event trigger or another scheduled job
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    await context.scheduler.runJob({
      name: REMIND_ME_ACTION_NAME,
      data: {
        userId: context.userId!,
        postId: `t3_${context.postId}`,
      },
      runAt: tomorrow,
    });
  },
});

export default Devvit;
```

### Schedule a recurring action

You can schedule an action that repeats at a specific time. This sample code creates a recurring action to post a new daily thread every day at 12:00 UTC. In this example, the recurring action is initiated when the app is installed, but you can also schedule a recurring action from a menu action instead.

```ts
import { Devvit } from '@devvit/public-api';

Devvit.addSchedulerJob({
  name: 'daily_thread',
  onRun: async (_, context) => {
    console.log('daily_thread handler called');
    const subreddit = await context.reddit.getCurrentSubreddit();
    const resp = await context.reddit.submitPost({
      subredditName: subreddit.name,
      title: 'Daily Thread',
      text: 'This is a daily thread, comment here!',
    });
    console.log('posted resp', JSON.stringify(resp));
  },
});

Devvit.addTrigger({
  event: 'AppInstall',
  onEvent: async (_, context) => {
    try {
      const jobId = await context.scheduler.runJob({
        cron: '0 12 * * *',
        name: 'daily_thread',
        data: {},
      });
      await context.redis.set('jobId', jobId);
    } catch (e) {
      console.log('error was not able to schedule:', e);
      throw e;
    }
  },
});

export default Devvit;
```

:::note
We recommend using [Cronitor](https://crontab.guru/) to build out strings.
:::

## Faster scheduler

:::note
This feature is experimental, which means the design is not final but it's still available for you to use.
:::

Scheduled jobs currently perform one scheduled run per minute. To go faster, you can now run jobs every second by adding seconds granularity to your cron expression.

```tsx
await scheduler.runJob({
  name: 'run_every_30_seconds',
  cron: '*/30 * * * * *',
});
```

How frequent a scheduled job runs will depend on how long the job takes to complete and how many jobs are running in parallel. This means a job may take a bit longer than scheduled, but the overall resolution should be better than a minute.

## Limitations

_Limits are per installation of an app_

1. An installation can have up to 10 live recurring actions.

2. There are two rate limits enforced by the `runJob()` method when actions are created:
   - Creation rate: up to 60 calls to `runJob()` per minute
   - Delivery rate: up to 60 deliveries per minute




# Secrets storage

Store sensitive data in your app.

There are times when you’ll want to store information in your app that should not be visible to users. Secrets are variables that contain sensitive information like API keys, credentials and tokens. Devvit lets you store and access secrets in three steps:

1. Define secrets in the app.
2. Provide secrets via Devvit CLI.
3. Retrieve secrets in the app.

## Defining secrets

You can use the existing `Devvit.addSettings` DX to define secrets.

```tsx
import { Devvit } from '@devvit/public-api';

Devvit.addSettings([
  {
    // Name of the setting which is used to retrieve the setting value
    name: 'open-ai-api-key',
    // This label is used to provide more information in the CLI
    label: 'Open AI API key',
    // Type of the setting value
    type: 'string',
    // Marks a setting as sensitive info - all secrets are encrypted
    isSecret: true,
    // Defines the access scope
    // app-scope ensures only developers can create/replace secrets via CLI
    scope: 'app',
  },
]);
```

## Providing secrets

You will be able to list app-scoped keys via the CLI. Use the `devvit settings` command in a Devvit project.

```bash
devvit settings list

Key               Label            Is this a secret?   Type
───────────────  ──────────────    ─────────────────   ──────
open-ai-api-key  Open AI API key    true            STRING
```

Once you access the keys, you can assign values to the secret keys. This operation can only be performed by app developers, not mods or installers.

```bash
devvit settings set open-ai-api-key

? Enter the value you would like to assign to the variable open-ai-api-key : <value>

Updating app settings... ✅
Successfully added app settings for open-ai-api-key!
```

## Retrieving secrets

Once you’ve stored the secrets via CLI, your app can access the secrets during invocations using `context.settings.get(secretName)` method.

<details><summary>Code Example</summary>

```tsx
import { Devvit, useState } from '@devvit/public-api';

Devvit.configure({
  http: true,
});

Devvit.addSettings([
  {
    name: 'open-ai-api-key',
    label: 'Open AI API key',
    type: 'string',
    isSecret: true,
    scope: 'app',
  },
]);

async function fetchResponse(context: Devvit.Context): Promise<string> {
  try {
    const apiKey = await context.settings.get('open-ai-api-key');

    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      method: 'POST',
      body: JSON.stringify({
        model: 'gpt-4-turbo',
        messages: [{ role: 'system', content: 'You are a helpful assistant.' }],
      }),
    });

    const json = await res.json();

    return json?.choices?.length > 0 ? json?.choices[0]?.message?.content : 'No response';
  } catch (e: any) {
    console.log('Fetch error ', e);
    return e.toString();
  }
}

Devvit.addCustomPostType({
  name: 'Devvit - Ask GPT',
  render: (context) => {
    const [answer, setAnswer] = useState<string>('');

    async function onPress() {
      const response = await fetchResponse(context);
      setAnswer(response || 'No Response');
    }

    return (
      <blocks height="tall">
        <vstack alignment="center middle" height="100%" gap="large">
          <button appearance="primary" onPress={onPress}>
            {'Ask GPT'}
          </button>
          <text wrap>{answer}</text>
        </vstack>
      </blocks>
    );
  },
});

export default Devvit;
```

</details>

## Limitations

- At least one app installation is required before you can store secrets via the CLI. You can use Devvit [playtest](/docs/get-started/playtest.md) once with the latest `Devvit.addSettings` config to accomplish this.
- App setting values are currently not surfaced in the CLI.


# Server-side functions

Devvit apps that create interactive posts generally run on the client side, which exposes code to users and clients for performance purposes. However, there are scenarios where you might want to keep certain parts of your codebase private—such as proprietary algorithms, sensitive data handling, or secure operations. Server-side functions allow you to store server-side code that remains hidden from clients.

## How it works

To add server-side code to your app, structure your project in one of the following ways:

Create a server folder for server-side code in your project directory: `<project-directory>/server/yourCode.ts`

Add .server. to your filename to indicate that it contains server-side code: `<project-directory>/yourModule.server.ts`

Any functions or modules imported from these server-side files will be executed on the server and keep implementation details hidden from the client.

Example:

Project Structure:

- project-directory/
  - index.tsx
  - server/
    - randomNumber.ts

Client-side Code (index.tsx):

```tsx
import { Devvit, useState } from '@devvit/public-api';
import { getRandomNumber } from './server/randomNumber.js;

Devvit.configure({
  http: true,
});

Devvit.addCustomPostType({
  name: 'Random Number Generator',
  render: () => {
    const [number, setNumber] = useState<number | null>(null);

    async function fetchRandomNumber() {
      const result = await getRandomNumber();
      setNumber(result);
    }

    return (
      <blocks>
        <vstack alignment="center middle" gap="medium">
          <button appearance="primary" onPress={fetchRandomNumber}>
            Generate Random Number
          </button>
          {number !== null && <text>Your number: {number}</text>}
        </vstack>
      </blocks>
    );
  },
});

export default Devvit;
```

Server-side Code (server/randomNumber.ts):

```tsx
export async function getRandomNumber(): Promise<number> {
  return Math.floor(Math.random() * 100) + 1;
}
```

## Limitations

Server-side functions may add performance overhead by introducing network latency. You’ll want to minimize unnecessary server interactions to keep your app responsive. For high-traffic apps, avoid making server calls during the first render unless necessary and leverage useAsync to perform server side calls without blocking the render process.


# Triggers

Build automatic actions into your app.

A trigger is an action you can build into your app that will occur automatically when the trigger condition is met.

## Event triggers

Event triggers let your app automatically respond to a user’s action. For example, if you set the PostSubmit trigger, the app will automatically respond when a new post is made in the community. These triggers types are supported:

- `PostSubmit`
- `PostCreate`
- `PostUpdate`
- `PostReport`
- `PostDelete`
- `PostFlairUpdate`
- `CommentCreate`
- `CommentDelete`
- `CommentReport`
- `CommentSubmit`
- `CommentUpdate`
- [`PostNsfwUpdate`](#nsfw-example)
- [`PostSpoilerUpdate`](#spoiler-example)
- [`AppInstall`](#setup-triggers)
- [`AppUpgrade`](#setup-triggers)
- [`ModActions`](#mod-actions)
- [`ModMail`](#modmail-trigger)
- [`AutomoderatorFilterPost`](#automoderator-triggers)
- [`AutomoderatorFilterComment`](#automoderator-triggers)

This example adds event triggers that will automatically execute your app. Once a trigger is added, your app listens for the event and the event handler executes the action.

```tsx
import { Devvit } from '@devvit/public-api';

// Handling a PostSubmit event
Devvit.addTrigger({
  event: 'PostSubmit', // Event name from above
  onEvent: async (event) => {
    console.log(`Received OnPostSubmit event:\n${JSON.stringify(event)}`);
  },
});

// Handling multiple events: PostUpdate and PostReport
Devvit.addTrigger({
  events: ['PostUpdate', 'PostReport'], // An array of events
  onEvent: async (event) => {
    if (event.type == 'PostUpdate') {
      console.log(`Received OnPostUpdate event:\n${JSON.stringify(request)}`);
    } else if (event.type === 'PostReport') {
      console.log(`Received OnPostReport event:\n${JSON.stringify(request)}`);
    }
  },
});

export default Devvit;
```

:::note

Be careful when creating recursive triggers (like a comment trigger that creates a comment). This could cause your app to crash. To avoid this, check to see if the content creator is the app.

:::

## Setup triggers

Setup triggers allow your app to automatically respond when a user is installing or configuring that app.
These triggers are supported:

- `AppInstall`
- `AppUpgrade`

## Mod triggers

### Modmail trigger

```ts
event: 'ModMail',
```

This alerts the mod when modmail is sent or received. This example enables the app to listen to modmail events and fetch the relevant message payload via the Reddit API wrapper.

```tsx
import { Devvit } from '@devvit/public-api';

Devvit.configure({ redditAPI: true });

Devvit.addTrigger({
  event: 'ModMail',
  onEvent: async (event, context) => {
    // Apps receive this event when:
    // 1. A new modmail conversation thread is created
    // 2. A new modmail message is added to an existing conversation
    console.log(`Received modmail trigger event:\n${JSON.stringify(event)}`);

    // Example conversation ID: ModmailConversation_1mzkfh
    // We are fetching the latest conversation state from Reddit API
    const conversationId = event.conversationId;
    const result = await context.reddit.modMail.getConversation({
      conversationId: conversationId,
      markRead: false,
    });
    console.log(`Received conversation with subject:   ${result.conversation?.subject}`);

    // Looking up the incoming message from trigger event
    // Example Message ID: ModmailMessage_2ch154
    const messageId = event.messageId.split('_')[1];
    const message = result.messages[messageId];
    console.log(`Received modmail message: ${JSON.stringify(message)}`);
  },
});

export default Devvit;
```

### NSFW and spoiler triggers

These are triggered when a mod or automod marks a post as NSFW or a spoiler.

:::note
NSFW and spoiler triggers only work for user posts that a moderator flags. Moderators cannot trigger a label for their own posts.
:::

#### NSFW example

```tsx
Devvit.addTrigger({
  event: 'PostNsfwUpdate',
  onEvent: async (event, context) => {
    // App received this event when:
    // 1. moderator changes a non-moderator post to nsfw
    // 2. automoderator changes post from nsfw to sfw
    console.log(`Received nsfw trigger event:\n${JSON.stringify(event)}`);
    if (event.isNsfw) {
      console.log(`This is event ${JSON.stringify(event)} changed to nsfw`);
    } else {
      console.log(`This is event ${JSON.stringify(event)} changed to non-nsfw`);
    }
  },
});
```

#### Spoiler example

```tsx
Devvit.addTrigger({
  event: 'PostSpoilerUpdate',
  onEvent: async (event, context) => {
    // App received this event when:
    // 1. moderator changes a non-moderator post to spoiler
    // 2. moderator changes post from spoiler to non-spoiler

    console.log(`Received spoiler trigger event:\n${JSON.stringify(event)}`);
    if (event.isSpoiler) {
      console.log(`This is event ${JSON.stringify(event)} changed to spoiler`);
    } else {
      console.log(`This is event ${JSON.stringify(event)} changed to non-spoiler`);
    }
  },
});
```

## Mod actions

Mod actions are another kind of trigger that are just for mods. These triggers show up in the mod log. Check out the list of available [mod actions](/docs/mod_actions.md), and if you don't see an action you want, let us know in [r/devvit modmail](https://reddit.com/message/compose/?to=/r/Devvit).

```ts
Devvit.addTrigger({
  event: 'ModAction',
  async onEvent(event, context) {
    if (event.action === 'banuser') {
      console.log(`A new user ${event.targetUser?.name} was banned!`);
    }
  },
});
```

## Automoderator triggers

These triggers are invoked when automoderator filters a post or a comment into the mod queue. Along with the post or comment this object also includes `removedAt` and `reason` (if available) fields.

```ts
Devvit.addTrigger({
  event: 'AutomoderatorFilterPost',
  onEvent: async (event) => {
    console.log(`Received AutomoderatorFilterPost event:\n${JSON.stringify(event)}`);
  },
});

Devvit.addTrigger({
  event: 'AutomoderatorFilterComment',
  onEvent: async (event) => {
    console.log(`Received AutomoderatorFilterComment event:\n${JSON.stringify(event)}`);
  },
});
```

# Working with useState

`useState` is a hook that gives your component reactive memory. It allows you to preserve information across renders and trigger updates to your app when state is updated.

## Arguments

`useState` takes an initial state as an argument, and returns an array of two items:

- a state variable
- a setter function to update the state variable

The initializer for `useState` (the first argument of the function) can be a static value or a function. **Regardless of how it is initialized, it must return a valid JSON value.** This differs from React due to how Devvit components work across server and client boundaries.

```ts
// A static value
const [variable, setVariable] = useState('initialState');

// An synchronous function
const [variable, setVariable] = useState(() => 'initialState');

// An async function
const [count, setCount] = useState(async () => await redis.get('count'));
```

:::info
If the initializer function is async it will block render under the value is resolved. This is a common performance pitfall so please use it sparingly or group async calls together into one state variable using [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all).

A non-blocking equivalent for fetching data is [useAsync](/docs/working_with_useasync.md).
:::

## Updating state

You’ll want to retrieve and update state at various points in your app. There are a few common patterns you’ll see for doing this.

```tsx
import { Devvit, useState } from '@devvit/public-api';

const MyComponent = (_, context) => {
  // Setting up state
  const [count, setCount] = useState(async () => {
    return await context.redis.get('count');
  });

  return (
    <hstack>
      <text>Count: {count}</text>
      {/* Update set count by using a setter function */}
      <button onPress={() => setCount((x) => x + 1)}>Increment</button>
      <button onPress={() => setCount((x) => x - 1)}>Decrement</button>
      {/* Update set count by setting the value directly */}
      <button onPress={() => setCount(0)}>Set to 0</button>
    </hstack>
  );
};
```

## Using state hooks

Leverage `useState` across components to preserve values and trigger reactive updates across your app.

In this example, state hooks are used to:

- Navigate between two app "pages"
- Add a simple counter that increments a value

```tsx
//define types of props to pass to components
interface Props {
  navigate: (page: PageType) => void;
  setCount: (count: number) => void;
  count: number;
}

enum PageType {
  HOMEPAGE,
  COUNTPAGE,
}

//useState is available as a global import from public API.
const App: Devvit.CustomPostComponent = ({ useState }: Devvit.Context) => {
  // set state components
  const [page, navigate] = useState(PageType.HOMEPAGE);
  const [count, setCount] = useState(0);

  // pass state into a Props object. This can be passed to components for passing state across components in your app
  const props: Props = {
    navigate,
    setCount,
    count,
  };

  // pass props into components
  if (page === PageType.COUNTPAGE) {
    return <CountPage {...props} />;
  } else {
    return <HomePage {...props} />;
  }
};

//'HomePage' is a component that returns this app's default UI
const HomePage: Devvit.BlockComponent<Props> = ({ navigate }) => {
  //defines how to handle 'onPress' button event on page
  const countPage: Devvit.Blocks.OnPressEventHandler = () => {
    navigate(PageType.COUNTPAGE);
  };

  //UI blocks comprising a page
  return (
    <vstack padding="medium" gap="medium" alignment="top center" cornerRadius="medium">
      <text size="xxlarge" weight="bold" grow>
        {'This app will teach you how to count!'}
      </text>
      <vstack alignment="center bottom">
        <button onPress={countPage} appearance="secondary">
          Start counting!
        </button>
      </vstack>
    </vstack>
  );
};

//'CountPage'component
const CountPage: Devvit.BlockComponent<Props> = ({ navigate, setCount, count }, { redis }) => {
  const incrementCount: Devvit.Blocks.OnPressEventHandler = () => {
    setCount((count) => count + 1);
    // note: to preserve the value of 'count' longerterm
    // you would need to add a separate method here. For example:
    // await redis.set("count", count)
  };

  return (
    <vstack padding="medium" gap="medium" alignment="top center" cornerRadius="medium">
      <text size="xxlarge" weight="bold" grow>
        {'Press the button to add +1'}
      </text>
      <text>{count}</text>
      <vstack alignment="center bottom">
        <button onPress={incrementCount} appearance="secondary">
          Count!
        </button>
      </vstack>
    </vstack>
  );
};

//add your custom post
Devvit.addCustomPostType({
  name: 'AppName',
  description: 'Navigate between pages and count!',
  render: App,
});
```

In this example, when a user session ends, state will no longer be available to the app. To save and persist data between sessions you will need to [store data server-side via the Redis](https://developers.reddit.com/docs/redis).

## Redis vs useState

The `redis` [plugin](https://developers.reddit.com/docs/redis) serves as your app’s long-term, server-side memory, while `useState` serves as its short-term, client-side memory.

`useState` will keep your custom posts performant and responsive. UI that relies on too many server-side calls will slow down your app.

The `redis` plugin should be used for storing data that needs to persist across sessions. Make these updates to your app in the background i.e. separate from the UI updates you are making. This way, your app does not need to wait on expensive calls to render new components. You should retrieve `redis` data once on render.

Use state hooks for single session memory, like changing tabs, selecting a checkbox within the UI, or changing values in the user’s view during their app session.

## User sessions

`useState` persists through a single user session. If a user scrolls away from the page, navigates away from the page, or disconnects, the session will end and the state is invalidated.

## Differences compared to React

The Devvit `useState` hook is inspired by [React](https://react.dev/reference/react/useState) with a few key differences.

- `useState` can only return something that can be serialized to JSON. That is booleans, numbers, strings, arrays, and objects. This is due to how the hook persists across server/client boundaries under the hood.
- `useState` can be initialized with an async function. This allows you to get remote information from Redis, Reddit, or by using fetch to place on to state. Please use this sparingly, as using an async initializer blocks render until the promise resolves. This can make your app feel slow.

# Working with useInterval

Update live interactive posts in real time.

:::note
This feature is experimental. There are known issues with interval timing especially when using server side calls, like calling Redis, within the useInterval function. This would result in intervals longer than what a developer specifies.
:::

The `useInterval` method lets you build live apps that automatically update in real time. You can use this method to trigger a render of your interactive post to do things like add a countdown timer, update a scoreboard with new play information, or set up a clock.

![Countdown timer](./assets/custom-posts/custom-posts-useinterval.png)

## How it works

The `useInterval` method lets you request that your app be re-rendered at a specified interval. Intervals are set in milliseconds, with a 1000ms minimum.

```tsx
import { Devvit, useState, useInterval } from '@devvit/public-api';

const [counter, setCounter] = useState(1000);

const updateInterval = useInterval(() => {
  setCounter((counter) => counter - 1);
}, 1000);

updateInterval.start();
```

## Key limitations

- You can only use one active, running `useInterval` per app.
- The minimum allowed interval time is 1 second.
- The timing is specific to the app. Timing begins when a user engages with the app, and the time interval triggers a refresh. For example:
  - If you build a stopwatch and add 1000 ms each time the interval runs, the actual elapsed time would include the time between interval triggers and would be something like 1020 ms.
  - If you build a countdown timer, the time interval trigger subtracts the current time at render, so it will match the elapsed time.
- An interval runs while the post is visible on screen. If a user navigates away, it is suspended.

## useInterval vs scheduler

The `useInterval` method is different from the scheduler, in a few important ways:

- `useInterval`executes on the client and triggers updates to your app locally (it’s similar to setInterval on the web). It can re-render on the user's device to do things like create animations or refresh the screen.
- Scheduler executes on the server and can be used to run background processes.

## Example clock app

### [Playground link](https://developers.reddit.com/play#pen/N4IgdghgtgpiBcIQBoQGcBOBjBICWUADgPYYAuABMACIwBudeZAvhQGYbFQUDkAAgBN6jMgHpCAVwBGAGzxYAtBEJ4eAHTAa2EsFjJ5iYCgHMYZAMISMGGGDIAVAjAAUASioaKFLIbSUwxADuFAC8FGAwwdQQZC6unt6+lAAWxFZooRQAymQYeGDGzgGBAHSmZAASaRhobq4lhBACORDkzgBMyLwADDzxRolgfhRQ+RKxGWE5eQVFQWVmALJjE3UNTS1tnT19CT5DlGgw+wKT2bn5hcULZFnHhqdrjc1krWQdXTy9-V42ZFZGAAGABJgKl0sx4KDRmBxjA0JDQUcTgjARpmBoNLQGEwSk0BJY-FwAArEPz2ACehBcwASkFg8F45hkxCwAGseMgEjYwEIMIz9rEAB6UEIAPg8Ay8+2GAG19LAukcHE4ALqZQUwEUlCRHFqxZxuUIS8qWay2FWwOoJaVJCj6dmZI3iijKxxW50msxmnmWuI-LyDYVkHVHACSdhgGDoEBkzgdbK6AEZuqn6n43m5MVKKH8ARRnDbAwAeOgZx2xvDGMCwOwhHhYC1RkZ4AQCGQwHgUZIwKvJMghNQgFPdACkQ7FRcDFGLwddeAAXjB60KhTJWqYeGLgAqYMxi6Jg5Oc14D2XXuzj9OAxiwMx+hotSRyBQhGwIBIZJRsSINCgQHQUZoAYYAIEmzBAA)

### Code sample

```tsx
import { Devvit, useState, useInterval } from '@devvit/public-api';

function getCurrentTime() {
  const now = new Date();
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
}

Devvit.addCustomPostType({
  name: 'Clock',
  render: (context) => {
    const [time, setTime] = useState(() => getCurrentTime());
    const tick = () => setTime(() => getCurrentTime());
    useInterval(tick, 1000).start();

    return (
      <vstack alignment="center middle" height="100%">
        <text size="xxlarge">{time}</text>
      </vstack>
    );
  },
});

export default Devvit;
```

# Working with useAsync

:::note
This feature is experimental, which means the design is not final but it's still available for you to use.
:::

`useAsync` is a hook that allows your app to perform server side calls like `redis.get` or `reddit.getCurrentUser` without blocking the render process.

## Blocking versus non-blocking

The code you write in Javascript can be blocking or non-blocking. To keep applications speedy, non-blocking code is preferred.

Blocking code produces a waterfall of actions. One line must happen after another, so the speed in which a program can render takes a large hit. We want to avoid waterfalls to provide a nice experience for users.

### Without useAsync (blocking) example

```tsx
const App = () => {
  // This will block the render until data is fetched
  const [message] = useState(async () => await redis.get('welcomeMessage'));

  return <text>{message}</text>;
};
```

### With useAsync (non-blocking) example

```tsx
const App = () => {
  const { data: message, loading, error } = useAsync(async () => await redis.get('welcomeMessage'));

  return (
    <vstack>
      {loading && <text>Loading...</text>}
      {error && <text>Error fetching message</text>}
      {message && <text>{message}</text>}
    </vstack>
  );
};
```

This example displays “Loading…” immediately while fetching the data.

## Understanding useAsync

### Syntax

```ts
const { data, loading, error } = useAsync(asyncFunction, { depends: {JSON object}, finally: () => { function }  });
```

- asyncFunction: an asynchronous function that must return a valid JSON value. Note that setState is not allowed in this function. Use the finally parameter if you need to use setState (see the example below).
- depends (optional): a JSON object or array of JSON objects that, when changed, will cause the asyncFunction to re-execute.
- finally (optional): a callback function that runs after the async operation completes regardless of success or failure. Ideal for state updates (i.e. calls to setState) and side effects.

### Return values

- data: the data returned from the initializer.
- loading: a boolean that denotes if it is loading or not.
- error: an error if the request failed.

**The initializer for `useAsync` (the first argument of the function) must return a valid JSON value.** This differs from React due to how Devvit components work across server and client boundaries.

### Example: fetching the time and setting state

```ts
useAsync(
  async () => {
    const response = await fetch(`https://date.api/today?timezone=${timezone}`);
    return response.json();
  },
  {
    depends: [timezone],
    finally: (data, error) => {
      if (error) {
        console.error('Failed to load date data:', error);
      } else {
        setTodayDate(data['currentDate']);
      }
    },
  }
);
```

### Example: fetching user data

```ts
// A normal useAsync function
const {
  data: username,
  loading: usernameLoading,
  error: usernameError,
} = useAsync(async () => {
  const user = await ctx.reddit.getCurrentUser();

  return user?.username ?? null;
});

// A dependent useAsync function
const {
  data: userDetails,
  loading: userDetailsLoading,
  error: userDetailsError,
} = useAsync(
  // This will run every time the value in depends changes
  async () => {
    if (!username) return null;

    const resp = await fetch(`https://some-api/get-user-details/${username}`);
    return await resp.json();
  },
  {
    // NOTE: This will be deep equality for objects and arrays!
    depends: username,
  }
);
```

### Example: complete application

This a simple application that leverages useAsync to fetch data in a non-blocking way and updates the app whenever the page changes.

```ts
import { useAsync, useState } from '@devvit/public-api';

const App = () => {
  const [count, setCount] = useState(1);

  const { data, loading, error } = useAsync(
    async () => {
      const response = await fetch(`https://xkcd.com/${count}/info.0.json`);
      if (!response.ok) throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
      return await response.json();
    },
    { depends: [count] }
  );

  return (
    <vstack alignment="center middle" height="100%" gap="small">
      <text size="large">XKCD Titles</text>
      <vstack>
        {loading && <text>Loading...</text>}
        {error && (
          <text color="red" wrap={true}>
            {error.message}
          </text>
        )}
        {data && <text>{data.title}</text>}
      </vstack>
      <text>Comic Number: {count}</text>
      <button onPress={() => setCount((prev) => prev + 1)}>Increment</button>
    </vstack>
  );
};

//add your custom post
Devvit.addCustomPostType({
  name: 'AppName',
  description: 'Using useAsync with XKCD API',
  render: App,
});
```

## When to use useAsync and useState

In most cases, you'll want to use `useAsync` over `useState` to keep your app snappy. One downside is that you need to handle `loading` and `error` when using `useAsync` or `useState`.

One situation where `useState` could be preferable is if your app only has one request and it must be resolved in order to show any part of the app.

Another time to consider `useState` is if you need to update the value you fetched and display the new result to the user. `useState` provides a better API for that, but keep in mind you still need to persist the updates to Redis. We will be working on making synced updates easier in the future.

:::note
There isn't an easy way to update `useAsync` data based off of an action in the app at the moment. We are working on a better way to allow this in the future.
:::

# Web views

Web views allow you to include HTML, CSS, and JavaScript and have it run within your Reddit app. This gives you full control over your app's appearance and behavior while running within Reddit's platform.

## Migration guide

<details>
  <summary>Click here for instructions on how to migrate from the web view component to the new useWebView hook.</summary>
  <div>
    <div>

This migration guide helps you migrate from using the web view component with visibility toggle, as used in our web-view-post template, to using the new useWebView hook. This will give you access to more gestures and sounds, and make sure your apps are performant in Reddit feeds.

**Overview**

The `useWebView` hook simplifies web view management with three main parameters:

- url: The URL of your web view content
- onMessage: Handler for messages from the web view
- onUnmount: Cleanup function that runs when the web view is closed

Instead of managing visibility with state, you'll use the mount function returned by the hook to open the web view.

**Before (web view component)**

```ts
// Managing visibility with state
const [webViewVisible, setWebViewVisible] = useState(false);

// Message handler
const onMessage = async (msg) => {
  if (msg.type === 'setCounter') {
    await context.redis.set(`counter_${context.postId}`, msg.data.newCounter.toString());
    setCounter(msg.data.newCounter);
  }
};

return (
  <vstack>
    <button onPress={() => setWebViewVisible(true)}>Launch App</button>
    {webViewVisible ? <webview id="myWebView" url="page.html" onMessage={onMessage} /> : null}
  </vstack>
);
```

**After (useWebView hook)**

```ts
import { useWebView } from '@devvit/public-api';

// Using useWebView hook
const { mount } = useWebView({
  // URL of your web view content
  url: 'page.html',

  // Message handler
  onMessage: async (message, webView) => {
    if (message.type === 'setCounter') {
      await context.redis.set(`counter_${context.postId}`, message.data.newCounter.toString());
      setCounter(message.data.newCounter);
    }
  },

  // Cleanup when web view is closed
  onUnmount: () => {
    context.ui.showToast('Web view closed!');
  },
});

return (
  <vstack>
    <button onPress={mount}>Launch App</button>
  </vstack>
);
```

**Key Differences**

1. Opening the web view

Old: Web view component was open immediately
The old web-view-post template toggled visibility with state (setWebViewVisible(true))

New: Use mount function from the hook

2. Message Handling

Old: Separate onMessage function passed as a parameter to component
New: Defined directly in useWebView parameters, along with access to an onUnmount function

3. Cleanup

Old: N/A
New: onUnmount parameter handles callback after cleanup

</div>
    <br/>
  </div>
</details>

Supported platforms:

- iOS (v2025.05)
- Android (v2025.05)
- Web

## Getting started

Create a new web view project:

```bash
devvit new --template web-view-post
cd my-project
```

Your project structure will look like this.

```
my-project/
├── webroot/          # All web content goes here
│   ├── page.html     # Main HTML file
│   ├── styles.css    # Stylesheets
│   └── app.js        # JavaScript code
└── src/
    └── main.tsx      # Devvit app code
```

## useWebView

The `useWebViewHook` integrates web views into your Devvit app. This opens a large viewport (full screen on mobile and a modal on web) and provides a clean interface for managing the web view lifecycle and communication.

### Syntax

```typescript
/** Message from Devvit to the web view. */
export type DevvitMessage =
  | { type: 'initialData'; data: { username: string; currentCounter: number } }
  | { type: 'updateCounter'; data: { currentCounter: number } };

/** Message from the web view to Devvit. */
export type WebViewMessage =
  | { type: 'webViewReady' }
  | { type: 'setCounter'; data: { newCounter: number } };

const { mount, unmount, postMessage } = useWebView<WebViewMessage, DevvitMessage>({
  url: 'page.html',
  onMessage: (message, webView) => {},
  onUnmount: () => {},
});
```

- url: the path to your HTML file relative to the webroot directory (defaults to ‘index.html’ if unspecified)
- onMessage: callback function that handles messages received from the web view; it receives two parameters:
  - message: the data sent from the web view via postMessage
  - webView: an object containing methods to interact with the web view
- onUnmount (optional): callback function that runs when the web view is closed. This does not fire on navigation or closing the browser tab.

Return values:

- mount: function to programmatically open the web view
- unmount: function to programmatically close the web view
- postMessage: function to send a message to the web view

### Basic example

```typescript
const App = () => {
  const { mount } = useWebView({
    // URL of your web view content
    url: 'page.html',

    // Handle messages from web view
    onMessage: (message) => {
      console.log('Received from web view:', message);
    },

    // Cleanup when web view closes
    onUnmount: () => {
      console.log('Web view closed');
    },
  });

  return <button onPress={mount}>Launch App</button>;
};
```

Be sure to call `mount` after some user interaction, like a button press, so that it's clear to the user what initiated the fullscreen presentation.

:::note
Web views that are presented in fullscreen without user interaction will not be approved.
:::

## Best practices

### UI/UX patterns

- Handle responsive views across mobile and desktop devices
- Call mount only after user interaction (e.g. onPress)

### File organization

- Keep all web files in the webroot/ directory
- Use separate files for HTML, CSS, and JavaScript
- Consider using a bundler for larger applications

### Data Synchronization

- Cache data in localStorage where appropriate
- Wait to send messages to the web view until the web view is fully loaded

## Known limitations

### CSS/JS requirements

- ❌ No inline CSS or JavaScript
- ✅ Use separate .css and .js files

### Forms

- ❌ No direct form submissions
- ✅ Use JavaScript to handle form data
- ✅ Send data via postMessage

## Communication between Devvit and web view

Web views let you build custom UIs with HTML/CSS/JS while accessing Devvit's backend services ([Redis](./capabilities/redis.md), [fetch](./capabilities/http-fetch.md), [scheduler](./capabilities/scheduler.md), [triggers](./capabilities/triggers.md)) via message passing between the two contexts.

![Sample web views post](./assets/webviews-devvit-architecture.png)

### From web view to Devvit

In your web view JavaScript:

```javascript
// app.js
window.parent.postMessage(
  {
    type: 'userAction',
    data: { clicked: true },
  },
  '*'
);
```

In your Devvit app:

```typescript
// main.tsx
const { mount } = useWebView({
  url: 'page.html',
  onMessage: (message, webView) => {
    if (message.type === 'userAction') {
      console.log('User clicked:', message.data.clicked);
    } else if (message.type === 'unmount') {
      webView.unmount();
    }
  },
});
```

### From Devvit to web view

In your Devvit app:

```typescript
// main.tsx
const { mount } = useWebView({
  url: 'page.html',
  onMessage: (message, webView) => {
    if (message.type === 'userAction') {
      console.log('User clicked:', message.data.clicked);
      webView.postMessage({
        type: 'userActionHandled',
        data: { userActionComplete: true },
      });
    }
  },
});
```

In your web view JavaScript:

```javascript
// app.js
window.addEventListener('message', (event) => {
  if (event.data.type === 'devvit-message') {
    const { message } = event.data;
    console.log('Received from Devvit:', message);
  }
});
```

## Managing state

### Handling initial state

Use `postMessage` to inject the initial state from the Devvit app into the web view after it is mounted. To ensure the web view is loaded before sending messages to it, send a message to the Devvit app requesting the initial state.

#### From web view to Devvit

In your web view JavaScript:

```javascript
// app.js
// Inform the Devvit app that the web view is ready to receive messages
addEventListener('load', (event) => {
  window.parent.postMessage({ type: 'webViewReady' }, '*');
});
```

In your Devvit app:

```typescript
// main.tsx
const { mount } = useWebView({
  url: 'page.html',
  onMessage: (message, webView) => {
    if (message.type === 'webViewReady') {
      webView.postMessage({ data: { score: 44 } });
    }
  },
});
```

### Local state

Persist local state using `localStorage`, which is fast, secure, and available on all platforms.

Web views can use `localStorage` for client-side persistence:

```javascript
// Save data
localStorage.setItem('gameState', JSON.stringify(state));

// Load data
const savedState = localStorage.getItem('gameState');
```

### Server state

To allow for state to sync across devices, data should be persisted using Redis within the Devvit app. It's recommended to frequently store state using `localStorage`, which is faster and use Redis less frequently.

```typescript
const App = () => {
  // Load data from Redis
  const [counter] = useState(async () => {
    const value = await context.redis.get(`counter_${context.postId}`);
    return Number(value ?? 0);
  });

  const { mount } = useWebView({
    url: 'page.html',
    onMessage: async (message) => {
      if (message.type === 'updateCounter') {
        // Update Redis
        await context.redis.set(`counter_${context.postId}`, message.data.newValue);
      }
    },
  });

  return <button onPress={mount}>Open App</button>;
};
```

## Adding payments

Adding [payments](payments/payments_add.md) to your app is pretty straightforward, but there are a couple of things to you need to know when also using web views.

For a full working example, see `devvit new --template=payments-web-view`.

### Using events to handle payments

Your user will interact with a web view, but payments APIs can only be invoked in blocks. To make this work, you need to:

- Use events (from web view to Devvit) to communicate that the user wants to purchase a product.
- Use events (from Devvit to the web view) to communicate whether purchase succeeds and what the user purchased.

### Communicating between web view and payments

Both your web view and payments integrations need to be declared in the same `addCustomPostType` block. At that point, the lambdas given to each integration will be able to reference each other:

```typescript
const payments = usePayments((result: OnPurchaseResult) => {
  // Tell the web view that a purchase was made.
  // A full example might validate that the purchase was successful & communicate what was purchased.
  webView.postMessage({
    type: 'purchaseMade',
    data: {},
  });
});
const webView = useWebView<WebViewMessage, DevvitMessage>({
  url: 'page.html',
  async onMessage(message) {
    // Trigger a payment, based on user interaction in the web view.
    // A full example might check that the user is eligible to make the purchased indicated -
    // for instance validating they aren't trying to purchase something they've already purchased
    // or are otherwise ineligible to purchase.
    if (message.type === 'purchase') {
      payments.purchase(message.data.sku);
    }
  },
});
```

